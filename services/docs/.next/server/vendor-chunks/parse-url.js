"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parse-url";
exports.ids = ["vendor-chunks/parse-url"];
exports.modules = {

/***/ "../../../../.yarn/berry/cache/parse-url-npm-8.1.0-0995f15c34-10c0.zip/node_modules/parse-url/dist/index.js":
/*!******************************************************************************************************************!*\
  !*** ../../../../.yarn/berry/cache/parse-url-npm-8.1.0-0995f15c34-10c0.zip/node_modules/parse-url/dist/index.js ***!
  \******************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar parsePath = __webpack_require__(/*! parse-path */ \"../../../../.yarn/berry/cache/parse-path-npm-7.0.0-ceda41e594-10c0.zip/node_modules/parse-path/lib/index.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar parsePath__default = /*#__PURE__*/_interopDefaultLegacy(parsePath);\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\nconst DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';\nconst DATA_URL_DEFAULT_CHARSET = 'us-ascii';\n\nconst testParameter = (name, filters) => filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);\n\nconst normalizeDataURL = (urlString, {stripHash}) => {\n\tconst match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n\n\tif (!match) {\n\t\tthrow new Error(`Invalid URL: ${urlString}`);\n\t}\n\n\tlet {type, data, hash} = match.groups;\n\tconst mediaType = type.split(';');\n\thash = stripHash ? '' : hash;\n\n\tlet isBase64 = false;\n\tif (mediaType[mediaType.length - 1] === 'base64') {\n\t\tmediaType.pop();\n\t\tisBase64 = true;\n\t}\n\n\t// Lowercase MIME type\n\tconst mimeType = (mediaType.shift() || '').toLowerCase();\n\tconst attributes = mediaType\n\t\t.map(attribute => {\n\t\t\tlet [key, value = ''] = attribute.split('=').map(string => string.trim());\n\n\t\t\t// Lowercase `charset`\n\t\t\tif (key === 'charset') {\n\t\t\t\tvalue = value.toLowerCase();\n\n\t\t\t\tif (value === DATA_URL_DEFAULT_CHARSET) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn `${key}${value ? `=${value}` : ''}`;\n\t\t})\n\t\t.filter(Boolean);\n\n\tconst normalizedMediaType = [\n\t\t...attributes,\n\t];\n\n\tif (isBase64) {\n\t\tnormalizedMediaType.push('base64');\n\t}\n\n\tif (normalizedMediaType.length > 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {\n\t\tnormalizedMediaType.unshift(mimeType);\n\t}\n\n\treturn `data:${normalizedMediaType.join(';')},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ''}`;\n};\n\nfunction normalizeUrl(urlString, options) {\n\toptions = {\n\t\tdefaultProtocol: 'http:',\n\t\tnormalizeProtocol: true,\n\t\tforceHttp: false,\n\t\tforceHttps: false,\n\t\tstripAuthentication: true,\n\t\tstripHash: false,\n\t\tstripTextFragment: true,\n\t\tstripWWW: true,\n\t\tremoveQueryParameters: [/^utm_\\w+/i],\n\t\tremoveTrailingSlash: true,\n\t\tremoveSingleSlash: true,\n\t\tremoveDirectoryIndex: false,\n\t\tsortQueryParameters: true,\n\t\t...options,\n\t};\n\n\turlString = urlString.trim();\n\n\t// Data URL\n\tif (/^data:/i.test(urlString)) {\n\t\treturn normalizeDataURL(urlString, options);\n\t}\n\n\tif (/^view-source:/i.test(urlString)) {\n\t\tthrow new Error('`view-source:` is not supported as it is a non-standard protocol');\n\t}\n\n\tconst hasRelativeProtocol = urlString.startsWith('//');\n\tconst isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n\n\t// Prepend protocol\n\tif (!isRelativeUrl) {\n\t\turlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n\t}\n\n\tconst urlObject = new URL(urlString);\n\n\tif (options.forceHttp && options.forceHttps) {\n\t\tthrow new Error('The `forceHttp` and `forceHttps` options cannot be used together');\n\t}\n\n\tif (options.forceHttp && urlObject.protocol === 'https:') {\n\t\turlObject.protocol = 'http:';\n\t}\n\n\tif (options.forceHttps && urlObject.protocol === 'http:') {\n\t\turlObject.protocol = 'https:';\n\t}\n\n\t// Remove auth\n\tif (options.stripAuthentication) {\n\t\turlObject.username = '';\n\t\turlObject.password = '';\n\t}\n\n\t// Remove hash\n\tif (options.stripHash) {\n\t\turlObject.hash = '';\n\t} else if (options.stripTextFragment) {\n\t\turlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, '');\n\t}\n\n\t// Remove duplicate slashes if not preceded by a protocol\n\t// NOTE: This could be implemented using a single negative lookbehind\n\t// regex, but we avoid that to maintain compatibility with older js engines\n\t// which do not have support for that feature.\n\tif (urlObject.pathname) {\n\t\t// TODO: Replace everything below with `urlObject.pathname = urlObject.pathname.replace(/(?<!\\b[a-z][a-z\\d+\\-.]{1,50}:)\\/{2,}/g, '/');` when Safari supports negative lookbehind.\n\n\t\t// Split the string by occurrences of this protocol regex, and perform\n\t\t// duplicate-slash replacement on the strings between those occurrences\n\t\t// (if any).\n\t\tconst protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n\n\t\tlet lastIndex = 0;\n\t\tlet result = '';\n\t\tfor (;;) {\n\t\t\tconst match = protocolRegex.exec(urlObject.pathname);\n\t\t\tif (!match) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst protocol = match[0];\n\t\t\tconst protocolAtIndex = match.index;\n\t\t\tconst intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n\n\t\t\tresult += intermediate.replace(/\\/{2,}/g, '/');\n\t\t\tresult += protocol;\n\t\t\tlastIndex = protocolAtIndex + protocol.length;\n\t\t}\n\n\t\tconst remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n\t\tresult += remnant.replace(/\\/{2,}/g, '/');\n\n\t\turlObject.pathname = result;\n\t}\n\n\t// Decode URI octets\n\tif (urlObject.pathname) {\n\t\ttry {\n\t\t\turlObject.pathname = decodeURI(urlObject.pathname);\n\t\t} catch {}\n\t}\n\n\t// Remove directory index\n\tif (options.removeDirectoryIndex === true) {\n\t\toptions.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n\t}\n\n\tif (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n\t\tlet pathComponents = urlObject.pathname.split('/');\n\t\tconst lastComponent = pathComponents[pathComponents.length - 1];\n\n\t\tif (testParameter(lastComponent, options.removeDirectoryIndex)) {\n\t\t\tpathComponents = pathComponents.slice(0, -1);\n\t\t\turlObject.pathname = pathComponents.slice(1).join('/') + '/';\n\t\t}\n\t}\n\n\tif (urlObject.hostname) {\n\t\t// Remove trailing dot\n\t\turlObject.hostname = urlObject.hostname.replace(/\\.$/, '');\n\n\t\t// Remove `www.`\n\t\tif (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n\t\t\t// Each label should be max 63 at length (min: 1).\n\t\t\t// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\n\t\t\t// Each TLD should be up to 63 characters long (min: 2).\n\t\t\t// It is technically possible to have a single character TLD, but none currently exist.\n\t\t\turlObject.hostname = urlObject.hostname.replace(/^www\\./, '');\n\t\t}\n\t}\n\n\t// Remove query unwanted parameters\n\tif (Array.isArray(options.removeQueryParameters)) {\n\t\t// eslint-disable-next-line unicorn/no-useless-spread -- We are intentionally spreading to get a copy.\n\t\tfor (const key of [...urlObject.searchParams.keys()]) {\n\t\t\tif (testParameter(key, options.removeQueryParameters)) {\n\t\t\t\turlObject.searchParams.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (options.removeQueryParameters === true) {\n\t\turlObject.search = '';\n\t}\n\n\t// Sort query parameters\n\tif (options.sortQueryParameters) {\n\t\turlObject.searchParams.sort();\n\n\t\t// Calling `.sort()` encodes the search parameters, so we need to decode them again.\n\t\ttry {\n\t\t\turlObject.search = decodeURIComponent(urlObject.search);\n\t\t} catch {}\n\t}\n\n\tif (options.removeTrailingSlash) {\n\t\turlObject.pathname = urlObject.pathname.replace(/\\/$/, '');\n\t}\n\n\tconst oldUrlString = urlString;\n\n\t// Take advantage of many of the Node `url` normalizations\n\turlString = urlObject.toString();\n\n\tif (!options.removeSingleSlash && urlObject.pathname === '/' && !oldUrlString.endsWith('/') && urlObject.hash === '') {\n\t\turlString = urlString.replace(/\\/$/, '');\n\t}\n\n\t// Remove ending `/` unless removeSingleSlash is false\n\tif ((options.removeTrailingSlash || urlObject.pathname === '/') && urlObject.hash === '' && options.removeSingleSlash) {\n\t\turlString = urlString.replace(/\\/$/, '');\n\t}\n\n\t// Restore relative protocol, if applicable\n\tif (hasRelativeProtocol && !options.normalizeProtocol) {\n\t\turlString = urlString.replace(/^http:\\/\\//, '//');\n\t}\n\n\t// Remove http/https\n\tif (options.stripProtocol) {\n\t\turlString = urlString.replace(/^(?:https?:)?\\/\\//, '');\n\t}\n\n\treturn urlString;\n}\n\n// Dependencies\n\n/**\n * parseUrl\n * Parses the input url.\n *\n * **Note**: This *throws* if invalid urls are provided.\n *\n * @name parseUrl\n * @function\n * @param {String} url The input url.\n * @param {Boolean|Object} normalize Whether to normalize the url or not.\n *                         Default is `false`. If `true`, the url will\n *                         be normalized. If an object, it will be the\n *                         options object sent to [`normalize-url`](https://github.com/sindresorhus/normalize-url).\n *\n *                         For SSH urls, normalize won't work.\n *\n * @return {Object} An object containing the following fields:\n *\n *    - `protocols` (Array): An array with the url protocols (usually it has one element).\n *    - `protocol` (String): The first protocol, `\"ssh\"` (if the url is a ssh url) or `\"file\"`.\n *    - `port` (null|Number): The domain port.\n *    - `resource` (String): The url domain (including subdomains).\n *    - `user` (String): The authentication user (usually for ssh urls).\n *    - `pathname` (String): The url pathname.\n *    - `hash` (String): The url hash.\n *    - `search` (String): The url querystring value.\n *    - `href` (String): The input url.\n *    - `query` (Object): The url querystring, parsed as object.\n *    - `parse_failed` (Boolean): Whether the parsing failed or not.\n */\nconst parseUrl = (url, normalize = false) => {\n\n    // Constants\n    const GIT_RE = /^(?:([a-z_][a-z0-9_-]{0,31})@|https?:\\/\\/)([\\w\\.\\-@]+)[\\/:]([\\~,\\.\\w,\\-,\\_,\\/]+?(?:\\.git|\\/)?)$/;\n\n    const throwErr = msg => {\n        const err = new Error(msg);\n        err.subject_url = url;\n        throw err\n    };\n\n    if (typeof url !== \"string\" || !url.trim()) {\n        throwErr(\"Invalid url.\");\n    }\n\n    if (url.length > parseUrl.MAX_INPUT_LENGTH) {\n        throwErr(\"Input exceeds maximum length. If needed, change the value of parseUrl.MAX_INPUT_LENGTH.\");\n    }\n\n    if (normalize) {\n        if (typeof normalize !== \"object\") {\n            normalize = {\n                stripHash: false\n            };\n        }\n        url = normalizeUrl(url, normalize);\n    }\n\n    const parsed = parsePath__default[\"default\"](url);\n\n    // Potential git-ssh urls\n    if (parsed.parse_failed) {\n        const matched = parsed.href.match(GIT_RE);\n\n        if (matched) {\n            parsed.protocols = [\"ssh\"];\n            parsed.protocol = \"ssh\";\n            parsed.resource = matched[2];\n            parsed.host = matched[2];\n            parsed.user = matched[1];\n            parsed.pathname = `/${matched[3]}`;\n            parsed.parse_failed = false;\n        } else {\n            throwErr(\"URL parsing failed.\");\n        }\n    }\n\n    return parsed;\n};\n\nparseUrl.MAX_INPUT_LENGTH = 2048;\n\nmodule.exports = parseUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vLnlhcm4vYmVycnkvY2FjaGUvcGFyc2UtdXJsLW5wbS04LjEuMC0wOTk1ZjE1YzM0LTEwYzAuemlwL25vZGVfbW9kdWxlcy9wYXJzZS11cmwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQywrSEFBWTs7QUFFcEMscUNBQXFDLDREQUE0RDs7QUFFakc7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxVQUFVO0FBQ2hEOztBQUVBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7O0FBRUEsTUFBTSxrQkFBa0I7QUFDeEIsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxJQUFJLEVBQUUsWUFBWSxNQUFNLE9BQU87QUFDNUMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiwyQkFBMkIsR0FBRyxHQUFHLDhCQUE4QixFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ3hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILEtBQUssS0FBSyxHQUFHLFNBQVM7O0FBRXhJO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsR0FBRzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsS0FBSyxhQUFhLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsS0FBSzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZG9jcy8uLi8uLi8uLi8uLi8ueWFybi9iZXJyeS9jYWNoZS9wYXJzZS11cmwtbnBtLTguMS4wLTA5OTVmMTVjMzQtMTBjMC56aXAvbm9kZV9tb2R1bGVzL3BhcnNlLXVybC9kaXN0L2luZGV4LmpzP2I3ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VQYXRoID0gcmVxdWlyZSgncGFyc2UtcGF0aCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIHBhcnNlUGF0aF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3kocGFyc2VQYXRoKTtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbmNvbnN0IERBVEFfVVJMX0RFRkFVTFRfTUlNRV9UWVBFID0gJ3RleHQvcGxhaW4nO1xuY29uc3QgREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUID0gJ3VzLWFzY2lpJztcblxuY29uc3QgdGVzdFBhcmFtZXRlciA9IChuYW1lLCBmaWx0ZXJzKSA9PiBmaWx0ZXJzLnNvbWUoZmlsdGVyID0+IGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCA/IGZpbHRlci50ZXN0KG5hbWUpIDogZmlsdGVyID09PSBuYW1lKTtcblxuY29uc3Qgbm9ybWFsaXplRGF0YVVSTCA9ICh1cmxTdHJpbmcsIHtzdHJpcEhhc2h9KSA9PiB7XG5cdGNvbnN0IG1hdGNoID0gL15kYXRhOig/PHR5cGU+W14sXSo/KSwoPzxkYXRhPlteI10qPykoPzojKD88aGFzaD4uKikpPyQvLmV4ZWModXJsU3RyaW5nKTtcblxuXHRpZiAoIW1hdGNoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHt1cmxTdHJpbmd9YCk7XG5cdH1cblxuXHRsZXQge3R5cGUsIGRhdGEsIGhhc2h9ID0gbWF0Y2guZ3JvdXBzO1xuXHRjb25zdCBtZWRpYVR5cGUgPSB0eXBlLnNwbGl0KCc7Jyk7XG5cdGhhc2ggPSBzdHJpcEhhc2ggPyAnJyA6IGhhc2g7XG5cblx0bGV0IGlzQmFzZTY0ID0gZmFsc2U7XG5cdGlmIChtZWRpYVR5cGVbbWVkaWFUeXBlLmxlbmd0aCAtIDFdID09PSAnYmFzZTY0Jykge1xuXHRcdG1lZGlhVHlwZS5wb3AoKTtcblx0XHRpc0Jhc2U2NCA9IHRydWU7XG5cdH1cblxuXHQvLyBMb3dlcmNhc2UgTUlNRSB0eXBlXG5cdGNvbnN0IG1pbWVUeXBlID0gKG1lZGlhVHlwZS5zaGlmdCgpIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRjb25zdCBhdHRyaWJ1dGVzID0gbWVkaWFUeXBlXG5cdFx0Lm1hcChhdHRyaWJ1dGUgPT4ge1xuXHRcdFx0bGV0IFtrZXksIHZhbHVlID0gJyddID0gYXR0cmlidXRlLnNwbGl0KCc9JykubWFwKHN0cmluZyA9PiBzdHJpbmcudHJpbSgpKTtcblxuXHRcdFx0Ly8gTG93ZXJjYXNlIGBjaGFyc2V0YFxuXHRcdFx0aWYgKGtleSA9PT0gJ2NoYXJzZXQnKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IERBVEFfVVJMX0RFRkFVTFRfQ0hBUlNFVCkge1xuXHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYCR7a2V5fSR7dmFsdWUgPyBgPSR7dmFsdWV9YCA6ICcnfWA7XG5cdFx0fSlcblx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdGNvbnN0IG5vcm1hbGl6ZWRNZWRpYVR5cGUgPSBbXG5cdFx0Li4uYXR0cmlidXRlcyxcblx0XTtcblxuXHRpZiAoaXNCYXNlNjQpIHtcblx0XHRub3JtYWxpemVkTWVkaWFUeXBlLnB1c2goJ2Jhc2U2NCcpO1xuXHR9XG5cblx0aWYgKG5vcm1hbGl6ZWRNZWRpYVR5cGUubGVuZ3RoID4gMCB8fCAobWltZVR5cGUgJiYgbWltZVR5cGUgIT09IERBVEFfVVJMX0RFRkFVTFRfTUlNRV9UWVBFKSkge1xuXHRcdG5vcm1hbGl6ZWRNZWRpYVR5cGUudW5zaGlmdChtaW1lVHlwZSk7XG5cdH1cblxuXHRyZXR1cm4gYGRhdGE6JHtub3JtYWxpemVkTWVkaWFUeXBlLmpvaW4oJzsnKX0sJHtpc0Jhc2U2NCA/IGRhdGEudHJpbSgpIDogZGF0YX0ke2hhc2ggPyBgIyR7aGFzaH1gIDogJyd9YDtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVybCh1cmxTdHJpbmcsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IHtcblx0XHRkZWZhdWx0UHJvdG9jb2w6ICdodHRwOicsXG5cdFx0bm9ybWFsaXplUHJvdG9jb2w6IHRydWUsXG5cdFx0Zm9yY2VIdHRwOiBmYWxzZSxcblx0XHRmb3JjZUh0dHBzOiBmYWxzZSxcblx0XHRzdHJpcEF1dGhlbnRpY2F0aW9uOiB0cnVlLFxuXHRcdHN0cmlwSGFzaDogZmFsc2UsXG5cdFx0c3RyaXBUZXh0RnJhZ21lbnQ6IHRydWUsXG5cdFx0c3RyaXBXV1c6IHRydWUsXG5cdFx0cmVtb3ZlUXVlcnlQYXJhbWV0ZXJzOiBbL151dG1fXFx3Ky9pXSxcblx0XHRyZW1vdmVUcmFpbGluZ1NsYXNoOiB0cnVlLFxuXHRcdHJlbW92ZVNpbmdsZVNsYXNoOiB0cnVlLFxuXHRcdHJlbW92ZURpcmVjdG9yeUluZGV4OiBmYWxzZSxcblx0XHRzb3J0UXVlcnlQYXJhbWV0ZXJzOiB0cnVlLFxuXHRcdC4uLm9wdGlvbnMsXG5cdH07XG5cblx0dXJsU3RyaW5nID0gdXJsU3RyaW5nLnRyaW0oKTtcblxuXHQvLyBEYXRhIFVSTFxuXHRpZiAoL15kYXRhOi9pLnRlc3QodXJsU3RyaW5nKSkge1xuXHRcdHJldHVybiBub3JtYWxpemVEYXRhVVJMKHVybFN0cmluZywgb3B0aW9ucyk7XG5cdH1cblxuXHRpZiAoL152aWV3LXNvdXJjZTovaS50ZXN0KHVybFN0cmluZykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2B2aWV3LXNvdXJjZTpgIGlzIG5vdCBzdXBwb3J0ZWQgYXMgaXQgaXMgYSBub24tc3RhbmRhcmQgcHJvdG9jb2wnKTtcblx0fVxuXG5cdGNvbnN0IGhhc1JlbGF0aXZlUHJvdG9jb2wgPSB1cmxTdHJpbmcuc3RhcnRzV2l0aCgnLy8nKTtcblx0Y29uc3QgaXNSZWxhdGl2ZVVybCA9ICFoYXNSZWxhdGl2ZVByb3RvY29sICYmIC9eXFwuKlxcLy8udGVzdCh1cmxTdHJpbmcpO1xuXG5cdC8vIFByZXBlbmQgcHJvdG9jb2xcblx0aWYgKCFpc1JlbGF0aXZlVXJsKSB7XG5cdFx0dXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL14oPyEoPzpcXHcrOik/XFwvXFwvKXxeXFwvXFwvLywgb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wpO1xuXHR9XG5cblx0Y29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuXG5cdGlmIChvcHRpb25zLmZvcmNlSHR0cCAmJiBvcHRpb25zLmZvcmNlSHR0cHMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZm9yY2VIdHRwYCBhbmQgYGZvcmNlSHR0cHNgIG9wdGlvbnMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXInKTtcblx0fVxuXG5cdGlmIChvcHRpb25zLmZvcmNlSHR0cCAmJiB1cmxPYmplY3QucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG5cdFx0dXJsT2JqZWN0LnByb3RvY29sID0gJ2h0dHA6Jztcblx0fVxuXG5cdGlmIChvcHRpb25zLmZvcmNlSHR0cHMgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSAnaHR0cDonKSB7XG5cdFx0dXJsT2JqZWN0LnByb3RvY29sID0gJ2h0dHBzOic7XG5cdH1cblxuXHQvLyBSZW1vdmUgYXV0aFxuXHRpZiAob3B0aW9ucy5zdHJpcEF1dGhlbnRpY2F0aW9uKSB7XG5cdFx0dXJsT2JqZWN0LnVzZXJuYW1lID0gJyc7XG5cdFx0dXJsT2JqZWN0LnBhc3N3b3JkID0gJyc7XG5cdH1cblxuXHQvLyBSZW1vdmUgaGFzaFxuXHRpZiAob3B0aW9ucy5zdHJpcEhhc2gpIHtcblx0XHR1cmxPYmplY3QuaGFzaCA9ICcnO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuc3RyaXBUZXh0RnJhZ21lbnQpIHtcblx0XHR1cmxPYmplY3QuaGFzaCA9IHVybE9iamVjdC5oYXNoLnJlcGxhY2UoLyM/On46dGV4dC4qPyQvaSwgJycpO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZSBzbGFzaGVzIGlmIG5vdCBwcmVjZWRlZCBieSBhIHByb3RvY29sXG5cdC8vIE5PVEU6IFRoaXMgY291bGQgYmUgaW1wbGVtZW50ZWQgdXNpbmcgYSBzaW5nbGUgbmVnYXRpdmUgbG9va2JlaGluZFxuXHQvLyByZWdleCwgYnV0IHdlIGF2b2lkIHRoYXQgdG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGpzIGVuZ2luZXNcblx0Ly8gd2hpY2ggZG8gbm90IGhhdmUgc3VwcG9ydCBmb3IgdGhhdCBmZWF0dXJlLlxuXHRpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG5cdFx0Ly8gVE9ETzogUmVwbGFjZSBldmVyeXRoaW5nIGJlbG93IHdpdGggYHVybE9iamVjdC5wYXRobmFtZSA9IHVybE9iamVjdC5wYXRobmFtZS5yZXBsYWNlKC8oPzwhXFxiW2Etel1bYS16XFxkK1xcLS5dezEsNTB9OilcXC97Mix9L2csICcvJyk7YCB3aGVuIFNhZmFyaSBzdXBwb3J0cyBuZWdhdGl2ZSBsb29rYmVoaW5kLlxuXG5cdFx0Ly8gU3BsaXQgdGhlIHN0cmluZyBieSBvY2N1cnJlbmNlcyBvZiB0aGlzIHByb3RvY29sIHJlZ2V4LCBhbmQgcGVyZm9ybVxuXHRcdC8vIGR1cGxpY2F0ZS1zbGFzaCByZXBsYWNlbWVudCBvbiB0aGUgc3RyaW5ncyBiZXR3ZWVuIHRob3NlIG9jY3VycmVuY2VzXG5cdFx0Ly8gKGlmIGFueSkuXG5cdFx0Y29uc3QgcHJvdG9jb2xSZWdleCA9IC9cXGJbYS16XVthLXpcXGQrXFwtLl17MSw1MH06XFwvXFwvL2c7XG5cblx0XHRsZXQgbGFzdEluZGV4ID0gMDtcblx0XHRsZXQgcmVzdWx0ID0gJyc7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBwcm90b2NvbFJlZ2V4LmV4ZWModXJsT2JqZWN0LnBhdGhuYW1lKTtcblx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHByb3RvY29sID0gbWF0Y2hbMF07XG5cdFx0XHRjb25zdCBwcm90b2NvbEF0SW5kZXggPSBtYXRjaC5pbmRleDtcblx0XHRcdGNvbnN0IGludGVybWVkaWF0ZSA9IHVybE9iamVjdC5wYXRobmFtZS5zbGljZShsYXN0SW5kZXgsIHByb3RvY29sQXRJbmRleCk7XG5cblx0XHRcdHJlc3VsdCArPSBpbnRlcm1lZGlhdGUucmVwbGFjZSgvXFwvezIsfS9nLCAnLycpO1xuXHRcdFx0cmVzdWx0ICs9IHByb3RvY29sO1xuXHRcdFx0bGFzdEluZGV4ID0gcHJvdG9jb2xBdEluZGV4ICsgcHJvdG9jb2wubGVuZ3RoO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlbW5hbnQgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCB1cmxPYmplY3QucGF0aG5hbWUubGVuZ3RoKTtcblx0XHRyZXN1bHQgKz0gcmVtbmFudC5yZXBsYWNlKC9cXC97Mix9L2csICcvJyk7XG5cblx0XHR1cmxPYmplY3QucGF0aG5hbWUgPSByZXN1bHQ7XG5cdH1cblxuXHQvLyBEZWNvZGUgVVJJIG9jdGV0c1xuXHRpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHVybE9iamVjdC5wYXRobmFtZSA9IGRlY29kZVVSSSh1cmxPYmplY3QucGF0aG5hbWUpO1xuXHRcdH0gY2F0Y2gge31cblx0fVxuXG5cdC8vIFJlbW92ZSBkaXJlY3RvcnkgaW5kZXhcblx0aWYgKG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPT09IHRydWUpIHtcblx0XHRvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4ID0gWy9eaW5kZXhcXC5bYS16XSskL107XG5cdH1cblxuXHRpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSAmJiBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4Lmxlbmd0aCA+IDApIHtcblx0XHRsZXQgcGF0aENvbXBvbmVudHMgPSB1cmxPYmplY3QucGF0aG5hbWUuc3BsaXQoJy8nKTtcblx0XHRjb25zdCBsYXN0Q29tcG9uZW50ID0gcGF0aENvbXBvbmVudHNbcGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMV07XG5cblx0XHRpZiAodGVzdFBhcmFtZXRlcihsYXN0Q29tcG9uZW50LCBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSkge1xuXHRcdFx0cGF0aENvbXBvbmVudHMgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgwLCAtMSk7XG5cdFx0XHR1cmxPYmplY3QucGF0aG5hbWUgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgxKS5qb2luKCcvJykgKyAnLyc7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHVybE9iamVjdC5ob3N0bmFtZSkge1xuXHRcdC8vIFJlbW92ZSB0cmFpbGluZyBkb3Rcblx0XHR1cmxPYmplY3QuaG9zdG5hbWUgPSB1cmxPYmplY3QuaG9zdG5hbWUucmVwbGFjZSgvXFwuJC8sICcnKTtcblxuXHRcdC8vIFJlbW92ZSBgd3d3LmBcblx0XHRpZiAob3B0aW9ucy5zdHJpcFdXVyAmJiAvXnd3d1xcLig/IXd3d1xcLilbYS16XFwtXFxkXXsxLDYzfVxcLlthLXouXFwtXFxkXXsyLDYzfSQvLnRlc3QodXJsT2JqZWN0Lmhvc3RuYW1lKSkge1xuXHRcdFx0Ly8gRWFjaCBsYWJlbCBzaG91bGQgYmUgbWF4IDYzIGF0IGxlbmd0aCAobWluOiAxKS5cblx0XHRcdC8vIFNvdXJjZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9zdG5hbWUjUmVzdHJpY3Rpb25zX29uX3ZhbGlkX2hvc3RfbmFtZXNcblx0XHRcdC8vIEVhY2ggVExEIHNob3VsZCBiZSB1cCB0byA2MyBjaGFyYWN0ZXJzIGxvbmcgKG1pbjogMikuXG5cdFx0XHQvLyBJdCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSB0byBoYXZlIGEgc2luZ2xlIGNoYXJhY3RlciBUTEQsIGJ1dCBub25lIGN1cnJlbnRseSBleGlzdC5cblx0XHRcdHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSBxdWVyeSB1bndhbnRlZCBwYXJhbWV0ZXJzXG5cdGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXVzZWxlc3Mtc3ByZWFkIC0tIFdlIGFyZSBpbnRlbnRpb25hbGx5IHNwcmVhZGluZyB0byBnZXQgYSBjb3B5LlxuXHRcdGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcblx0XHRcdGlmICh0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG5cdFx0XHRcdHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzID09PSB0cnVlKSB7XG5cdFx0dXJsT2JqZWN0LnNlYXJjaCA9ICcnO1xuXHR9XG5cblx0Ly8gU29ydCBxdWVyeSBwYXJhbWV0ZXJzXG5cdGlmIChvcHRpb25zLnNvcnRRdWVyeVBhcmFtZXRlcnMpIHtcblx0XHR1cmxPYmplY3Quc2VhcmNoUGFyYW1zLnNvcnQoKTtcblxuXHRcdC8vIENhbGxpbmcgYC5zb3J0KClgIGVuY29kZXMgdGhlIHNlYXJjaCBwYXJhbWV0ZXJzLCBzbyB3ZSBuZWVkIHRvIGRlY29kZSB0aGVtIGFnYWluLlxuXHRcdHRyeSB7XG5cdFx0XHR1cmxPYmplY3Quc2VhcmNoID0gZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iamVjdC5zZWFyY2gpO1xuXHRcdH0gY2F0Y2gge31cblx0fVxuXG5cdGlmIChvcHRpb25zLnJlbW92ZVRyYWlsaW5nU2xhc2gpIHtcblx0XHR1cmxPYmplY3QucGF0aG5hbWUgPSB1cmxPYmplY3QucGF0aG5hbWUucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0fVxuXG5cdGNvbnN0IG9sZFVybFN0cmluZyA9IHVybFN0cmluZztcblxuXHQvLyBUYWtlIGFkdmFudGFnZSBvZiBtYW55IG9mIHRoZSBOb2RlIGB1cmxgIG5vcm1hbGl6YXRpb25zXG5cdHVybFN0cmluZyA9IHVybE9iamVjdC50b1N0cmluZygpO1xuXG5cdGlmICghb3B0aW9ucy5yZW1vdmVTaW5nbGVTbGFzaCAmJiB1cmxPYmplY3QucGF0aG5hbWUgPT09ICcvJyAmJiAhb2xkVXJsU3RyaW5nLmVuZHNXaXRoKCcvJykgJiYgdXJsT2JqZWN0Lmhhc2ggPT09ICcnKSB7XG5cdFx0dXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdH1cblxuXHQvLyBSZW1vdmUgZW5kaW5nIGAvYCB1bmxlc3MgcmVtb3ZlU2luZ2xlU2xhc2ggaXMgZmFsc2Vcblx0aWYgKChvcHRpb25zLnJlbW92ZVRyYWlsaW5nU2xhc2ggfHwgdXJsT2JqZWN0LnBhdGhuYW1lID09PSAnLycpICYmIHVybE9iamVjdC5oYXNoID09PSAnJyAmJiBvcHRpb25zLnJlbW92ZVNpbmdsZVNsYXNoKSB7XG5cdFx0dXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdH1cblxuXHQvLyBSZXN0b3JlIHJlbGF0aXZlIHByb3RvY29sLCBpZiBhcHBsaWNhYmxlXG5cdGlmIChoYXNSZWxhdGl2ZVByb3RvY29sICYmICFvcHRpb25zLm5vcm1hbGl6ZVByb3RvY29sKSB7XG5cdFx0dXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sICcvLycpO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGh0dHAvaHR0cHNcblx0aWYgKG9wdGlvbnMuc3RyaXBQcm90b2NvbCkge1xuXHRcdHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD86aHR0cHM/Oik/XFwvXFwvLywgJycpO1xuXHR9XG5cblx0cmV0dXJuIHVybFN0cmluZztcbn1cblxuLy8gRGVwZW5kZW5jaWVzXG5cbi8qKlxuICogcGFyc2VVcmxcbiAqIFBhcnNlcyB0aGUgaW5wdXQgdXJsLlxuICpcbiAqICoqTm90ZSoqOiBUaGlzICp0aHJvd3MqIGlmIGludmFsaWQgdXJscyBhcmUgcHJvdmlkZWQuXG4gKlxuICogQG5hbWUgcGFyc2VVcmxcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgaW5wdXQgdXJsLlxuICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gbm9ybWFsaXplIFdoZXRoZXIgdG8gbm9ybWFsaXplIHRoZSB1cmwgb3Igbm90LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBgZmFsc2VgLiBJZiBgdHJ1ZWAsIHRoZSB1cmwgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgYmUgbm9ybWFsaXplZC4gSWYgYW4gb2JqZWN0LCBpdCB3aWxsIGJlIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyBvYmplY3Qgc2VudCB0byBbYG5vcm1hbGl6ZS11cmxgXShodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL25vcm1hbGl6ZS11cmwpLlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIEZvciBTU0ggdXJscywgbm9ybWFsaXplIHdvbid0IHdvcmsuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAqXG4gKiAgICAtIGBwcm90b2NvbHNgIChBcnJheSk6IEFuIGFycmF5IHdpdGggdGhlIHVybCBwcm90b2NvbHMgKHVzdWFsbHkgaXQgaGFzIG9uZSBlbGVtZW50KS5cbiAqICAgIC0gYHByb3RvY29sYCAoU3RyaW5nKTogVGhlIGZpcnN0IHByb3RvY29sLCBgXCJzc2hcImAgKGlmIHRoZSB1cmwgaXMgYSBzc2ggdXJsKSBvciBgXCJmaWxlXCJgLlxuICogICAgLSBgcG9ydGAgKG51bGx8TnVtYmVyKTogVGhlIGRvbWFpbiBwb3J0LlxuICogICAgLSBgcmVzb3VyY2VgIChTdHJpbmcpOiBUaGUgdXJsIGRvbWFpbiAoaW5jbHVkaW5nIHN1YmRvbWFpbnMpLlxuICogICAgLSBgdXNlcmAgKFN0cmluZyk6IFRoZSBhdXRoZW50aWNhdGlvbiB1c2VyICh1c3VhbGx5IGZvciBzc2ggdXJscykuXG4gKiAgICAtIGBwYXRobmFtZWAgKFN0cmluZyk6IFRoZSB1cmwgcGF0aG5hbWUuXG4gKiAgICAtIGBoYXNoYCAoU3RyaW5nKTogVGhlIHVybCBoYXNoLlxuICogICAgLSBgc2VhcmNoYCAoU3RyaW5nKTogVGhlIHVybCBxdWVyeXN0cmluZyB2YWx1ZS5cbiAqICAgIC0gYGhyZWZgIChTdHJpbmcpOiBUaGUgaW5wdXQgdXJsLlxuICogICAgLSBgcXVlcnlgIChPYmplY3QpOiBUaGUgdXJsIHF1ZXJ5c3RyaW5nLCBwYXJzZWQgYXMgb2JqZWN0LlxuICogICAgLSBgcGFyc2VfZmFpbGVkYCAoQm9vbGVhbik6IFdoZXRoZXIgdGhlIHBhcnNpbmcgZmFpbGVkIG9yIG5vdC5cbiAqL1xuY29uc3QgcGFyc2VVcmwgPSAodXJsLCBub3JtYWxpemUgPSBmYWxzZSkgPT4ge1xuXG4gICAgLy8gQ29uc3RhbnRzXG4gICAgY29uc3QgR0lUX1JFID0gL14oPzooW2Etel9dW2EtejAtOV8tXXswLDMxfSlAfGh0dHBzPzpcXC9cXC8pKFtcXHdcXC5cXC1AXSspW1xcLzpdKFtcXH4sXFwuXFx3LFxcLSxcXF8sXFwvXSs/KD86XFwuZ2l0fFxcLyk/KSQvO1xuXG4gICAgY29uc3QgdGhyb3dFcnIgPSBtc2cgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgZXJyLnN1YmplY3RfdXJsID0gdXJsO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgfHwgIXVybC50cmltKCkpIHtcbiAgICAgICAgdGhyb3dFcnIoXCJJbnZhbGlkIHVybC5cIik7XG4gICAgfVxuXG4gICAgaWYgKHVybC5sZW5ndGggPiBwYXJzZVVybC5NQVhfSU5QVVRfTEVOR1RIKSB7XG4gICAgICAgIHRocm93RXJyKFwiSW5wdXQgZXhjZWVkcyBtYXhpbXVtIGxlbmd0aC4gSWYgbmVlZGVkLCBjaGFuZ2UgdGhlIHZhbHVlIG9mIHBhcnNlVXJsLk1BWF9JTlBVVF9MRU5HVEguXCIpO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub3JtYWxpemUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZSA9IHtcbiAgICAgICAgICAgICAgICBzdHJpcEhhc2g6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IG5vcm1hbGl6ZVVybCh1cmwsIG5vcm1hbGl6ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VQYXRoX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh1cmwpO1xuXG4gICAgLy8gUG90ZW50aWFsIGdpdC1zc2ggdXJsc1xuICAgIGlmIChwYXJzZWQucGFyc2VfZmFpbGVkKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBwYXJzZWQuaHJlZi5tYXRjaChHSVRfUkUpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICBwYXJzZWQucHJvdG9jb2xzID0gW1wic3NoXCJdO1xuICAgICAgICAgICAgcGFyc2VkLnByb3RvY29sID0gXCJzc2hcIjtcbiAgICAgICAgICAgIHBhcnNlZC5yZXNvdXJjZSA9IG1hdGNoZWRbMl07XG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9IG1hdGNoZWRbMl07XG4gICAgICAgICAgICBwYXJzZWQudXNlciA9IG1hdGNoZWRbMV07XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBgLyR7bWF0Y2hlZFszXX1gO1xuICAgICAgICAgICAgcGFyc2VkLnBhcnNlX2ZhaWxlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnIoXCJVUkwgcGFyc2luZyBmYWlsZWQuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbnBhcnNlVXJsLk1BWF9JTlBVVF9MRU5HVEggPSAyMDQ4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVXJsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../../.yarn/berry/cache/parse-url-npm-8.1.0-0995f15c34-10c0.zip/node_modules/parse-url/dist/index.js\n");

/***/ })

};
;